<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EntityDB v2.32.0 Admin Console</title>
    
    <!-- Prevent caching -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- External libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #2d3748;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #2b6cb0;
            font-size: 1.8rem;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            background: #48bb78;
            color: white;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Tabs */
        .tabs {
            background: white;
            border-radius: 8px 8px 0 0;
            padding: 0;
            margin-bottom: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 15px 25px;
            font-size: 14px;
            font-weight: 500;
            color: #718096;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab-button:hover {
            color: #2b6cb0;
            background: #f7fafc;
        }

        .tab-button.active {
            color: #2b6cb0;
            border-bottom-color: #2b6cb0;
            background: #f7fafc;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tab-content.active {
            display: block;
        }

        /* Cards */
        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }

        .card h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        /* Grid layouts */
        .grid {
            display: grid;
            gap: 20px;
        }

        .grid-2 {
            grid-template-columns: 1fr 1fr;
        }

        .grid-3 {
            grid-template-columns: 1fr 1fr 1fr;
        }

        .grid-4 {
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }

        /* Metric cards */
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Charts */
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .chart-container canvas {
            max-height: 300px;
        }

        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .table th,
        .table td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .table th {
            background: #f7fafc;
            font-weight: 600;
            color: #2d3748;
        }

        .table tr:hover {
            background: #f7fafc;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #2b6cb0;
            color: white;
        }

        .btn-primary:hover {
            background: #2c5aa0;
        }

        .btn-secondary {
            background: #718096;
            color: white;
        }

        .btn-secondary:hover {
            background: #4a5568;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-header h2 {
            color: #2d3748;
            margin: 0;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            color: #718096;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #2d3748;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d3748;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #2b6cb0;
            box-shadow: 0 0 0 3px rgba(43, 108, 176, 0.1);
        }

        /* Tags */
        .tag {
            display: inline-block;
            background: #edf2f7;
            color: #2d3748;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin: 2px;
        }

        .tag.system {
            background: #fbb6ce;
            color: #702459;
        }

        .tag.user {
            background: #bee3f8;
            color: #2a69ac;
        }

        /* Alerts */
        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .alert-error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }

        .alert-warning {
            background: #fefcbf;
            color: #744210;
            border: 1px solid #f6e05e;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2b6cb0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .grid-2,
            .grid-3,
            .grid-4 {
                grid-template-columns: 1fr;
            }
            
            .tab-buttons {
                flex-wrap: wrap;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Time Range Selector */
        .time-range-selector {
            display: flex;
            gap: 2px;
            background: #f7fafc;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .time-range-btn {
            padding: 6px 12px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .time-range-btn:hover {
            background: #e2e8f0;
            color: #334155;
        }

        .time-range-btn.active {
            background: #2b6cb0;
            color: white;
            box-shadow: 0 2px 4px rgba(43, 108, 176, 0.3);
        }

        /* Chart Container Overlay Time Selectors */
        .chart-container {
            position: relative;
        }

        .chart-time-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            padding: 3px;
            border-radius: 6px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chart-time-btn {
            padding: 4px 8px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s ease;
            min-width: 28px;
        }

        .chart-time-btn:hover {
            background: rgba(226, 232, 240, 0.8);
            color: #334155;
        }

        .chart-time-btn.active {
            background: #2563eb;
            color: white;
            box-shadow: 0 1px 3px rgba(37, 99, 235, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>EntityDB v2.32.0 Admin Console</h1>
            <div class="user-info">
                <div class="dataset-selector" style="margin-right: 20px;">
                    <label style="font-size: 0.9rem; margin-right: 8px;">Dataset:</label>
                    <select id="datasetSelector" onchange="app.switchDataset()" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #cbd5e0;">
                        <option value="">Loading datasets...</option>
                    </select>
                </div>
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span id="connectionStatus">Connected</span>
                </div>
                <span id="currentUser">Loading...</span>
                <button class="btn btn-secondary btn-sm" onclick="app.logout()">Logout</button>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('dashboard')">Dashboard</button>
                <button class="tab-button" onclick="switchTab('entities')">Entities</button>
                <button class="tab-button" onclick="switchTab('performance')">Performance</button>
                <button class="tab-button" onclick="switchTab('metrics')">Metrics</button>
                <button class="tab-button" onclick="switchTab('temporal')">Temporal</button>
                <button class="tab-button" onclick="switchTab('users')">Users</button>
                <button class="tab-button" onclick="switchTab('datasets')">Datasets</button>
                <button class="tab-button" onclick="switchTab('system')">System</button>
                <button class="tab-button" onclick="switchTab('api')">API Console</button>
            </div>

            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="grid grid-4">
                    <div class="metric-card">
                        <div class="metric-value" id="totalEntities">-</div>
                        <div class="metric-label">Total Entities</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="activeUsers">-</div>
                        <div class="metric-label">Active Users</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="activeSessions">-</div>
                        <div class="metric-label">Active Sessions</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="systemHealth">-</div>
                        <div class="metric-label">System Health</div>
                    </div>
                </div>

                <div class="grid grid-2">
                    <div class="card">
                        <h3>System Performance</h3>
                        <div class="chart-container">
                            <div class="chart-time-overlay">
                                <button class="chart-time-btn active" onclick="app.setChartTimeRange('performance', '5m')">5m</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('performance', '1h')">1h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('performance', '6h')">6h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('performance', '24h')">24h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('performance', '7d')">7d</button>
                            </div>
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Memory Usage</h3>
                        <div class="chart-container">
                            <canvas id="memoryChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>Recent Activity</h3>
                    <div id="recentActivity">Loading...</div>
                </div>
            </div>

            <!-- Entities Tab -->
            <div id="entities" class="tab-content">
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>Entity Management</h3>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="form-group" style="margin: 0; flex-grow: 1; max-width: 400px;">
                            <input type="text" id="entitySearch" placeholder="Search entities..." 
                                   onkeyup="app.searchEntities()" style="margin: 0;">
                        </div>
                        <button class="btn btn-primary" onclick="app.showCreateEntityModal()">
                            <span style="margin-right: 5px;">+</span> Create Entity
                        </button>
                    </div>
                    
                    <div id="entitiesTable">Loading entities...</div>
                </div>
            </div>

            <!-- Performance Tab -->
            <div id="performance" class="tab-content">
                <div style="margin-bottom: 20px;">
                    <h3>Performance Monitoring</h3>
                </div>
                
                <div class="grid grid-3">
                    <div class="metric-card">
                        <div class="metric-value" id="avgResponseTime">-</div>
                        <div class="metric-label">Avg Response Time (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="requestsPerSecond">-</div>
                        <div class="metric-label">Requests/Second</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="errorRate">-</div>
                        <div class="metric-label">Error Rate (%)</div>
                    </div>
                </div>

                <div class="grid grid-2">
                    <div class="card">
                        <h3>Response Time Trends</h3>
                        <div class="chart-container">
                            <div class="chart-time-overlay">
                                <button class="chart-time-btn active" onclick="app.setChartTimeRange('responseTime', '5m')">5m</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('responseTime', '1h')">1h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('responseTime', '6h')">6h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('responseTime', '24h')">24h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('responseTime', '7d')">7d</button>
                            </div>
                            <canvas id="responseTimeChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Request Volume</h3>
                        <div class="chart-container">
                            <div class="chart-time-overlay">
                                <button class="chart-time-btn active" onclick="app.setChartTimeRange('requestVolume', '5m')">5m</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('requestVolume', '1h')">1h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('requestVolume', '6h')">6h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('requestVolume', '24h')">24h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('requestVolume', '7d')">7d</button>
                            </div>
                            <canvas id="requestVolumeChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>Storage Performance</h3>
                    <div class="grid grid-2">
                        <div class="chart-container">
                            <div class="chart-time-overlay">
                                <button class="chart-time-btn active" onclick="app.setChartTimeRange('storageRead', '5m')">5m</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageRead', '1h')">1h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageRead', '6h')">6h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageRead', '24h')">24h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageRead', '7d')">7d</button>
                            </div>
                            <canvas id="storageReadChart"></canvas>
                        </div>
                        <div class="chart-container">
                            <div class="chart-time-overlay">
                                <button class="chart-time-btn active" onclick="app.setChartTimeRange('storageWrite', '5m')">5m</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageWrite', '1h')">1h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageWrite', '6h')">6h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageWrite', '24h')">24h</button>
                                <button class="chart-time-btn" onclick="app.setChartTimeRange('storageWrite', '7d')">7d</button>
                            </div>
                            <canvas id="storageWriteChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Metrics Tab -->
            <div id="metrics" class="tab-content">
                <div class="card">
                    <h3>Live Metrics Dashboard</h3>
                    <div id="metricsData">Loading metrics...</div>
                </div>

                <div class="card">
                    <h3>Custom Metrics Query</h3>
                    <div class="form-group">
                        <label>Metric Name:</label>
                        <input type="text" id="metricName" placeholder="e.g., storage_read_duration_ms">
                    </div>
                    <div class="form-group">
                        <label>Time Range:</label>
                        <select id="timeRange">
                            <option value="1h">Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h">Last 24 Hours</option>
                            <option value="7d">Last 7 Days</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="app.queryMetrics()">Query Metrics</button>
                    
                    <div id="customMetricsChart" class="chart-container" style="display: none;">
                        <canvas id="customChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Temporal Tab -->
            <div id="temporal" class="tab-content">
                <div class="card">
                    <h3>Temporal Database Features ⏱️</h3>
                    <p>EntityDB v2.32.0 provides complete temporal database functionality with nanosecond precision timestamps.</p>
                    
                    <div class="grid grid-2">
                        <div class="card">
                            <h4>Time Travel Queries</h4>
                            <div class="form-group">
                                <label>Entity ID:</label>
                                <input type="text" id="temporalEntityId" placeholder="Enter entity ID">
                            </div>
                            <div class="form-group">
                                <label>Timestamp (ISO 8601):</label>
                                <input type="datetime-local" id="temporalTimestamp">
                            </div>
                            <button class="btn btn-primary" onclick="app.queryAsOf()">Query As-Of</button>
                            <button class="btn btn-secondary" onclick="app.queryHistory()">Get History</button>
                        </div>
                        
                        <div class="card">
                            <h4>Change Detection</h4>
                            <div class="form-group">
                                <label>From Time:</label>
                                <input type="datetime-local" id="temporalFromTime">
                            </div>
                            <div class="form-group">
                                <label>To Time:</label>
                                <input type="datetime-local" id="temporalToTime">
                            </div>
                            <button class="btn btn-primary" onclick="app.queryChanges()">Get Changes</button>
                            <button class="btn btn-secondary" onclick="app.queryDiff()">Get Diff</button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>Temporal Query Results</h4>
                        <div id="temporalResults" style="max-height: 400px; overflow-y: auto; background: #f7fafc; padding: 15px; border-radius: 6px;">
                            Select an entity and query type above to see temporal data...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Users Tab -->
            <div id="users" class="tab-content">
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>User Management</h3>
                        <button class="btn btn-primary" onclick="app.showCreateUserModal()">Create User</button>
                    </div>
                    <div id="usersTable">Loading users...</div>
                </div>
            </div>

            <!-- Datasets Tab -->
            <div id="datasets" class="tab-content">
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>Dataset Management</h3>
                        <button class="btn btn-primary" onclick="app.showCreateDatasetModal()">Create Dataset</button>
                    </div>
                    <div id="datasetsTable">Loading datasets...</div>
                </div>
            </div>

            <!-- System Tab -->
            <div id="system" class="tab-content">
                <div class="grid grid-2">
                    <div class="card">
                        <h3>System Information</h3>
                        <div id="systemInfo">Loading...</div>
                    </div>
                    <div class="card">
                        <h3>Database Statistics</h3>
                        <div id="dbStats">Loading...</div>
                    </div>
                </div>

                <div class="card">
                    <h3>System Logs</h3>
                    <div style="max-height: 400px; overflow-y: auto; background: #f7fafc; padding: 15px; border-radius: 6px;">
                        <div id="systemLogs">Loading logs...</div>
                    </div>
                </div>
            </div>

            <!-- API Console Tab -->
            <div id="api" class="tab-content">
                <div class="card">
                    <h3>API Testing Console</h3>
                    <div class="grid grid-2">
                        <div>
                            <div class="form-group">
                                <label>HTTP Method:</label>
                                <select id="apiMethod">
                                    <option value="GET">GET</option>
                                    <option value="POST">POST</option>
                                    <option value="PUT">PUT</option>
                                    <option value="DELETE">DELETE</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Endpoint:</label>
                                <input type="text" id="apiEndpoint" value="/api/v1/entities/list">
                            </div>
                            <div class="form-group">
                                <label>Request Body (JSON):</label>
                                <textarea id="apiBody" rows="10" placeholder='{"key": "value"}'></textarea>
                            </div>
                            <button class="btn btn-primary" onclick="app.testAPI()">Send Request</button>
                        </div>
                        <div>
                            <div class="form-group">
                                <label>Response:</label>
                                <textarea id="apiResponse" rows="20" readonly style="font-family: monospace; background: #f7fafc;"></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced EntityDB Admin Application
        class EntityDBAdmin {
            constructor() {
                this.baseURL = window.location.origin;
                this.token = localStorage.getItem('entitydb_token');
                this.refreshInterval = null;
                this.chartUpdateInterval = null;
                this.charts = {};
                this.currentTimeRange = '5m'; // Default to 5 minutes
                this.currentDataset = null; // Currently selected dataset
                this.datasets = []; // Available datasets
                this.timeRangeSettings = {
                    '5m': { minutes: 5, maxPoints: 30, interval: 10000 },
                    '1h': { minutes: 60, maxPoints: 60, interval: 60000 },
                    '6h': { minutes: 360, maxPoints: 72, interval: 300000 },
                    '12h': { minutes: 720, maxPoints: 72, interval: 600000 },
                    '24h': { minutes: 1440, maxPoints: 96, interval: 900000 },
                    '7d': { minutes: 10080, maxPoints: 168, interval: 3600000 },
                    '30d': { minutes: 43200, maxPoints: 180, interval: 14400000 },
                    '90d': { minutes: 129600, maxPoints: 180, interval: 43200000 }
                };
                
                if (this.token) {
                    this.init();
                } else {
                    this.showLogin();
                }
            }

            async init() {
                console.log('Initializing Enhanced EntityDB Admin...');
                await this.loadDatasetSelector();
                await this.refreshData();
                this.startAutoRefresh();
                await this.initCharts();
            }

            showLogin() {
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background: #f5f7fa;">
                        <div class="card" style="width: 400px; margin: 0;">
                            <h2 style="text-align: center; margin-bottom: 30px; color: #2b6cb0;">EntityDB Login</h2>
                            <div class="form-group">
                                <label>Username:</label>
                                <input type="text" id="username" value="admin">
                            </div>
                            <div class="form-group">
                                <label>Password:</label>
                                <input type="password" id="password" value="admin">
                            </div>
                            <button class="btn btn-primary" style="width: 100%;" onclick="app.login()">Login</button>
                            <div id="loginError" style="margin-top: 15px;"></div>
                        </div>
                    </div>
                `;
                
                // Handle enter key
                document.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.login();
                });
            }

            async login() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                
                try {
                    const response = await fetch(`${this.baseURL}/api/v1/auth/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        this.token = data.token;
                        localStorage.setItem('entitydb_token', this.token);
                        location.reload();
                    } else {
                        document.getElementById('loginError').innerHTML = 
                            `<div class="alert alert-error">${data.error || 'Login failed'}</div>`;
                    }
                } catch (error) {
                    document.getElementById('loginError').innerHTML = 
                        `<div class="alert alert-error">Connection error: ${error.message}</div>`;
                }
            }

            logout() {
                localStorage.removeItem('entitydb_token');
                location.reload();
            }

            async apiCall(endpoint, method = 'GET', body = null) {
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.token}`
                };

                const config = { method, headers };
                if (body) config.body = JSON.stringify(body);

                const response = await fetch(`${this.baseURL}${endpoint}`, config);
                
                if (response.status === 401) {
                    this.logout();
                    return;
                }
                
                return await response.json();
            }

            async refreshData() {
                try {
                    // Update connection status
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    
                    // PERFORMANCE FIX: Pre-validate session once per refresh cycle
                    // This prevents 5 simultaneous session validations every 30 seconds
                    if (this.token) {
                        try {
                            await this.apiCall('/health'); // Lightweight session validation
                        } catch (sessionError) {
                            console.warn('Session validation failed, redirecting to login');
                            this.logout();
                            return;
                        }
                    }
                    
                    // Load dashboard data - all calls now use pre-validated session
                    await this.loadDashboardData();
                    await this.loadEntities();
                    await this.loadUsers();
                    await this.loadDatasets();
                    await this.loadSystemInfo();
                    await this.loadMetrics();
                    
                } catch (error) {
                    console.error('Error refreshing data:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                }
            }

            async loadDashboardData() {
                try {
                    // Sequential calls to prevent session validation storms
                    const entities = await this.apiCall('/api/v1/entities/list');
                    const health = await this.apiCall('/health');
                    const users = await this.apiCall('/api/v1/rbac/metrics/public');

                    document.getElementById('totalEntities').textContent = entities.length || 0;
                    document.getElementById('activeUsers').textContent = users.active_users || 0;
                    document.getElementById('activeSessions').textContent = users.active_sessions || 0;
                    document.getElementById('systemHealth').textContent = health.status === 'healthy' ? '100%' : '50%';

                    // Update current user
                    const userEntities = entities.filter(e => e.tags?.some(t => t.includes('type:user')));
                    document.getElementById('currentUser').textContent = 'Admin User';

                } catch (error) {
                    console.error('Error loading dashboard data:', error);
                }
            }

            async loadEntities() {
                try {
                    // Load entities from current dataset if one is selected, otherwise global entities
                    const endpoint = this.currentDataset ? 
                        `/api/v1/datasets/${this.currentDataset}/entities/list` : 
                        '/api/v1/entities/list';
                    const entities = await this.apiCall(endpoint);
                    
                    const tableHTML = `
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Type</th>
                                    <th>Created</th>
                                    <th>Tags</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${entities.map(entity => `
                                    <tr>
                                        <td>${entity.id.substring(0, 12)}...</td>
                                        <td>${this.getEntityType(entity)}</td>
                                        <td>${this.formatDate(entity.created_at)}</td>
                                        <td>${entity.tags?.length || 0} tags</td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" onclick="app.viewEntity('${entity.id}')">View</button>
                                            <button class="btn btn-sm btn-secondary" onclick="app.editEntity('${entity.id}')">Edit</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                    
                    document.getElementById('entitiesTable').innerHTML = tableHTML;
                } catch (error) {
                    document.getElementById('entitiesTable').innerHTML = `<div class="alert alert-error">Error loading entities: ${error.message}</div>`;
                }
            }

            async loadUsers() {
                try {
                    const entities = await this.apiCall('/api/v1/entities/list');
                    const users = entities.filter(e => e.tags?.some(t => t.includes('type:user')));
                    
                    const tableHTML = `
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Username</th>
                                    <th>Status</th>
                                    <th>Roles</th>
                                    <th>Created</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${users.map(user => `
                                    <tr>
                                        <td>${user.id.substring(0, 12)}...</td>
                                        <td>${this.extractTagValue(user, 'identity:username')}</td>
                                        <td><span class="tag">${this.extractTagValue(user, 'status')}</span></td>
                                        <td>${this.extractTagValue(user, 'rbac:role')}</td>
                                        <td>${this.formatDate(user.created_at)}</td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" onclick="app.viewEntity('${user.id}')">View</button>
                                            <button class="btn btn-sm btn-secondary" onclick="app.showChangePasswordModal('${user.id}', '${this.extractTagValue(user, 'identity:username')}')">Change Password</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                    
                    document.getElementById('usersTable').innerHTML = tableHTML;
                } catch (error) {
                    document.getElementById('usersTable').innerHTML = `<div class="alert alert-error">Error loading users: ${error.message}</div>`;
                }
            }

            async loadDatasets() {
                try {
                    const datasets = await this.apiCall('/api/v1/datasets');
                    
                    const tableHTML = `
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Name</th>
                                    <th>Description</th>
                                    <th>Created</th>
                                    <th>Entities</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${datasets.map(dataset => `
                                    <tr>
                                        <td>${dataset.id.substring(0, 12)}...</td>
                                        <td><strong>${this.extractTagValue(dataset, 'name')}</strong></td>
                                        <td>${this.extractTagValue(dataset, 'description')}</td>
                                        <td>${this.formatDate(dataset.created_at)}</td>
                                        <td>0</td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" onclick="app.viewDataset('${dataset.id}')">View</button>
                                            <button class="btn btn-sm btn-secondary" onclick="app.editDataset('${dataset.id}')">Edit</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                    
                    document.getElementById('datasetsTable').innerHTML = tableHTML;
                } catch (error) {
                    document.getElementById('datasetsTable').innerHTML = `<div class="alert alert-error">Error loading datasets: ${error.message}</div>`;
                }
            }

            async loadSystemInfo() {
                try {
                    const [health, metrics] = await Promise.all([
                        this.apiCall('/health'),
                        this.apiCall('/api/v1/system/metrics')
                    ]);

                    document.getElementById('systemInfo').innerHTML = `
                        <div style="display: grid; gap: 10px;">
                            <div><strong>Status:</strong> ${health.status}</div>
                            <div><strong>Uptime:</strong> ${health.uptime || 'N/A'}</div>
                            <div><strong>Version:</strong> ${health.version || 'v2.32.0'}</div>
                            <div><strong>Memory:</strong> ${this.formatBytes(health.memory?.used || 0)}</div>
                        </div>
                    `;

                    document.getElementById('dbStats').innerHTML = `
                        <div style="display: grid; gap: 10px;">
                            <div><strong>Total Entities:</strong> ${metrics.entity_count || 0}</div>
                            <div><strong>Database Size:</strong> ${this.formatBytes(metrics.database_size || 0)}</div>
                            <div><strong>WAL Size:</strong> ${this.formatBytes(metrics.wal_size || 0)}</div>
                            <div><strong>Index Size:</strong> ${this.formatBytes(metrics.index_size || 0)}</div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error loading system info:', error);
                }
            }

            async loadMetrics() {
                try {
                    // Load metrics from the new async system
                    const entities = await this.apiCall('/api/v1/entities/list');
                    const metrics = entities.filter(e => e.tags?.some(t => t.includes('type:metric')));
                    
                    // Also load system metrics for charts
                    await this.updateCharts();
                    
                    const metricsHTML = `
                        <div class="grid grid-2">
                            <div>
                                <h4>Available Metrics (${metrics.length})</h4>
                                <ul style="list-style: none; padding: 0;">
                                    ${metrics.map(metric => `
                                        <li style="padding: 5px 0; border-bottom: 1px solid #eee;">
                                            <strong>${this.extractTagValue(metric, 'name')}</strong>
                                            <br><small>${this.extractTagValue(metric, 'description')}</small>
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                            <div>
                                <h4>Recent Values</h4>
                                <div id="metricValues">
                                    ${metrics.slice(0, 10).map(metric => `
                                        <div style="padding: 5px 0;">
                                            <strong>${this.extractTagValue(metric, 'name')}:</strong>
                                            ${this.getLatestValue(metric)} ${this.extractTagValue(metric, 'unit')}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.getElementById('metricsData').innerHTML = metricsHTML;
                } catch (error) {
                    document.getElementById('metricsData').innerHTML = `<div class="alert alert-error">Error loading metrics: ${error.message}</div>`;
                }
            }

            async updateCharts() {
                try {
                    const [health, systemMetrics] = await Promise.all([
                        this.apiCall('/health'),
                        this.apiCall('/api/v1/system/metrics')
                    ]);

                    const timestamp = this.formatTimeLabel(new Date());

                    // Update performance chart with REAL API response time
                    if (this.charts.performance) {
                        const startTime = performance.now();
                        await this.apiCall('/health');
                        const responseTime = Math.round(performance.now() - startTime);
                        this.updateChart(this.charts.performance, timestamp, responseTime);
                    }

                    // Update memory chart with REAL memory data
                    if (this.charts.memory && health.metrics?.memory_usage) {
                        const memUsed = health.metrics.memory_usage.alloc_bytes || 0;
                        const memTotal = health.metrics.memory_usage.sys_bytes || memUsed * 2;
                        const usedMB = Math.round(memUsed / 1024 / 1024);
                        const freeMB = Math.round((memTotal - memUsed) / 1024 / 1024);
                        
                        this.charts.memory.data.datasets[0].data = [usedMB, freeMB];
                        this.charts.memory.data.labels = [`Used (${usedMB}MB)`, `Free (${freeMB}MB)`];
                        this.charts.memory.update();
                    }

                    // Response time chart - same as performance for now
                    if (this.charts.responseTime) {
                        const startTime = performance.now();
                        await this.apiCall('/health');
                        const responseTime = Math.round(performance.now() - startTime);
                        this.updateChart(this.charts.responseTime, timestamp, responseTime);
                    }

                    // Request volume - use zero since we don't have real request metrics yet
                    if (this.charts.requestVolume) {
                        this.updateChart(this.charts.requestVolume, timestamp, 0);
                    }

                    // Storage IOPS - use zero since we don't have real storage metrics yet
                    if (this.charts.storageRead) {
                        this.updateChart(this.charts.storageRead, timestamp, 0);
                    }

                    if (this.charts.storageWrite) {
                        this.updateChart(this.charts.storageWrite, timestamp, 0);
                    }

                    // Update custom chart with REAL entity counts
                    if (this.charts.custom && systemMetrics?.data) {
                        const entityCount = systemMetrics.data.entities?.total_count || 0;
                        const userCount = systemMetrics.data.entities?.user_count || 0;
                        const sessionCount = health.metrics?.entity_count || 0;
                        const metricCount = systemMetrics.data.entities?.metric_count || 0;
                        
                        this.charts.custom.data.datasets[0].data = [entityCount, userCount, sessionCount, metricCount];
                        this.charts.custom.update();
                    }

                } catch (error) {
                    console.error('Error updating charts:', error);
                }
            }

            updateChart(chart, label, value) {
                if (!chart || !chart.data) return;
                
                const settings = this.timeRangeSettings[this.currentTimeRange];
                const maxDataPoints = settings.maxPoints;
                
                // Add new data point
                chart.data.labels.push(label);
                chart.data.datasets[0].data.push(value);
                
                // Remove old data points if too many
                if (chart.data.labels.length > maxDataPoints) {
                    chart.data.labels.shift();
                    chart.data.datasets[0].data.shift();
                }
                
                chart.update('none'); // Update without animation for performance
            }

            async initCharts() {
                // Initialize performance chart with 5-minute historical timeline
                const performanceCtx = document.getElementById('performanceChart');
                if (performanceCtx) {
                    this.charts.performance = new Chart(performanceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Response Time (ms)',
                                data: [],
                                borderColor: '#2b6cb0',
                                backgroundColor: 'rgba(43, 108, 176, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }

                // Initialize memory chart
                const memoryCtx = document.getElementById('memoryChart');
                if (memoryCtx) {
                    this.charts.memory = new Chart(memoryCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Used', 'Free'],
                            datasets: [{
                                data: [60, 40],
                                backgroundColor: ['#e53e3e', '#38a169']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }

                // Initialize response time chart
                const responseTimeCtx = document.getElementById('responseTimeChart');
                if (responseTimeCtx) {
                    this.charts.responseTime = new Chart(responseTimeCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Response Time (ms)',
                                data: [],
                                borderColor: '#38a169',
                                backgroundColor: 'rgba(56, 161, 105, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                    
                }

                // Initialize request volume chart
                const requestVolumeCtx = document.getElementById('requestVolumeChart');
                if (requestVolumeCtx) {
                    this.charts.requestVolume = new Chart(requestVolumeCtx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Requests/min',
                                data: [],
                                backgroundColor: '#4299e1',
                                borderColor: '#2b6cb0',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                    
                }

                // Initialize storage read chart
                const storageReadCtx = document.getElementById('storageReadChart');
                if (storageReadCtx) {
                    this.charts.storageRead = new Chart(storageReadCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Read IOPS',
                                data: [],
                                borderColor: '#9f7aea',
                                backgroundColor: 'rgba(159, 122, 234, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                    
                }

                // Initialize storage write chart
                const storageWriteCtx = document.getElementById('storageWriteChart');
                if (storageWriteCtx) {
                    this.charts.storageWrite = new Chart(storageWriteCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Write IOPS',
                                data: [],
                                borderColor: '#f56565',
                                backgroundColor: 'rgba(245, 101, 101, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                    
                }

                // Initialize custom chart
                const customCtx = document.getElementById('customChart');
                if (customCtx) {
                    this.charts.custom = new Chart(customCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Entities', 'Users', 'Sessions', 'Metrics'],
                            datasets: [{
                                label: 'Count',
                                data: [0, 0, 0, 0],
                                backgroundColor: ['#4299e1', '#38a169', '#ed8936', '#9f7aea'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }
                
                // Initialize historical data for all charts in sequence (not parallel)
                // This prevents session validation storms and CPU spinning
                setTimeout(() => this.initializeHistoricalDataSequentially(), 1000);
            }
            
            async initializeHistoricalDataSequentially() {
                // Prevent multiple concurrent initializations
                if (this.initializingCharts) {
                    console.log('Charts already initializing, skipping...');
                    return;
                }
                
                this.initializingCharts = true;
                console.log('Starting sequential historical data initialization...');
                
                const chartsToInitialize = [
                    'performance',
                    'responseTime', 
                    'requestVolume',
                    'storageRead',
                    'storageWrite'
                ];
                
                for (const chartId of chartsToInitialize) {
                    if (this.charts[chartId]) {
                        console.log(`Initializing historical data for ${chartId}...`);
                        try {
                            await this.initializeChartWithTimeRange(chartId, '5m');
                            console.log(`✓ Completed historical data for ${chartId}`);
                            // Small delay between each chart to prevent API flooding
                            await new Promise(resolve => setTimeout(resolve, 200));
                        } catch (error) {
                            console.warn(`Failed to initialize ${chartId}:`, error);
                        }
                    }
                }
                
                this.initializingCharts = false;
                console.log('✓ All charts initialized with historical data');
            }

            async viewEntity(entityId) {
                try {
                    const entity = await this.apiCall(`/api/v1/entities/get?id=${entityId}`);
                    this.showEntityModal(entity, false);
                } catch (error) {
                    this.showAlert('Failed to load entity: ' + error.message, 'error');
                }
            }

            async editEntity(entityId) {
                try {
                    const entity = await this.apiCall(`/api/v1/entities/get?id=${entityId}`);
                    this.showEntityModal(entity, true);
                } catch (error) {
                    this.showAlert('Failed to load entity: ' + error.message, 'error');
                }
            }

            showEntityModal(entity, isEdit) {
                const modalId = 'entityModal';
                let modal = document.getElementById(modalId);
                
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = modalId;
                    modal.className = 'modal';
                    document.body.appendChild(modal);
                }

                const entityType = this.getEntityType(entity);
                const tagsDisplay = entity.tags ? entity.tags.map(tag => `<span class="tag">${tag}</span>`).join(' ') : '';
                
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>${isEdit ? 'Edit' : 'View'} Entity</h2>
                            <span class="close" onclick="app.closeModal('${modalId}')">&times;</span>
                        </div>
                        
                        <div class="form-group">
                            <label>ID:</label>
                            <input type="text" value="${entity.id}" readonly style="background: #f5f5f5;">
                        </div>
                        
                        <div class="form-group">
                            <label>Type:</label>
                            <input type="text" value="${entityType}" readonly style="background: #f5f5f5;">
                        </div>
                        
                        <div class="form-group">
                            <label>Tags:</label>
                            <div style="border: 1px solid #e2e8f0; padding: 15px; min-height: 100px; background: white; border-radius: 6px;">
                                ${tagsDisplay}
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Content:</label>
                            <textarea id="entityContent" style="width: 100%; height: 200px; ${isEdit ? '' : 'background: #f5f5f5;'}" ${isEdit ? '' : 'readonly'}>${entity.content || ''}</textarea>
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                            <div>
                                <button class="btn btn-danger" onclick="app.deleteEntity('${entity.id}')">Delete Entity</button>
                            </div>
                            <div>
                                ${isEdit ? `
                                    <button class="btn btn-primary" onclick="app.saveEntity('${entity.id}')">Save Changes</button>
                                    <button class="btn btn-secondary" onclick="app.closeModal('${modalId}')">Cancel</button>
                                ` : `
                                    <button class="btn btn-primary" onclick="app.editEntity('${entity.id}')">Edit</button>
                                    <button class="btn btn-secondary" onclick="app.closeModal('${modalId}')">Close</button>
                                `}
                            </div>
                        </div>
                    </div>
                `;
                
                modal.style.display = 'block';
            }

            closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'none';
                }
            }

            async saveEntity(entityId) {
                try {
                    const content = document.getElementById('entityContent').value;
                    
                    await this.apiCall(`/api/v1/entities/update?id=${entityId}`, 'PUT', {
                        content: btoa(content) // Base64 encode content
                    });
                    
                    this.showAlert('Entity updated successfully!', 'success');
                    this.closeModal('entityModal');
                    await this.loadEntities(); // Refresh entity list
                } catch (error) {
                    this.showAlert('Failed to update entity: ' + error.message, 'error');
                }
            }

            async deleteEntity(entityId) {
                if (!confirm('Are you sure you want to delete this entity? This action cannot be undone.')) {
                    return;
                }
                
                try {
                    await this.apiCall(`/api/v1/entities/delete?id=${entityId}`, 'DELETE');
                    this.showAlert('Entity deleted successfully!', 'success');
                    this.closeModal('entityModal');
                    await this.loadEntities(); // Refresh entity list
                } catch (error) {
                    this.showAlert('Failed to delete entity: ' + error.message, 'error');
                }
            }

            showCreateEntityModal() {
                const modalId = 'createEntityModal';
                let modal = document.getElementById(modalId);
                
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = modalId;
                    modal.className = 'modal';
                    document.body.appendChild(modal);
                }

                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Create New Entity</h2>
                            <span class="close" onclick="app.closeModal('${modalId}')">&times;</span>
                        </div>
                        
                        <div class="form-group">
                            <label>Entity ID:</label>
                            <input type="text" id="newEntityId" placeholder="Enter unique entity ID" style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Type:</label>
                            <select id="newEntityType" style="width: 100%;">
                                <option value="document">Document</option>
                                <option value="user">User</option>
                                <option value="config">Configuration</option>
                                <option value="metric">Metric</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Tags (comma-separated):</label>
                            <input type="text" id="newEntityTags" placeholder="status:active, category:example" style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Content:</label>
                            <textarea id="newEntityContent" style="width: 100%; height: 200px;" placeholder="Enter entity content..."></textarea>
                        </div>
                        
                        <div style="text-align: right; margin-top: 20px;">
                            <button class="btn btn-primary" onclick="app.createEntity()">Create Entity</button>
                            <button class="btn btn-secondary" onclick="app.closeModal('${modalId}')">Cancel</button>
                        </div>
                    </div>
                `;
                
                modal.style.display = 'block';
            }

            async createEntity() {
                try {
                    const id = document.getElementById('newEntityId').value.trim();
                    const type = document.getElementById('newEntityType').value;
                    const tagsInput = document.getElementById('newEntityTags').value.trim();
                    const content = document.getElementById('newEntityContent').value;
                    
                    if (!id) {
                        this.showAlert('Entity ID is required', 'error');
                        return;
                    }
                    
                    // Build tags array
                    const tags = [`type:${type}`];
                    if (tagsInput) {
                        tags.push(...tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag));
                    }
                    
                    await this.apiCall('/api/v1/entities/create', 'POST', {
                        id: id,
                        tags: tags,
                        content: btoa(content) // Base64 encode content
                    });
                    
                    this.showAlert('Entity created successfully!', 'success');
                    this.closeModal('createEntityModal');
                    await this.loadEntities(); // Refresh entity list
                } catch (error) {
                    this.showAlert('Failed to create entity: ' + error.message, 'error');
                }
            }

            searchEntities() {
                const searchTerm = document.getElementById('entitySearch').value.toLowerCase();
                const tableRows = document.querySelectorAll('#entitiesTable tbody tr');
                
                tableRows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    row.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            }


            async loadHistoricalData() {
                try {
                    const settings = this.timeRangeSettings[this.currentTimeRange];
                    const endTime = new Date();
                    const startTime = new Date(endTime.getTime() - (settings.minutes * 60 * 1000));
                    
                    // For now, simulate historical data - in production this would call temporal endpoints
                    // Example: /api/v1/entities/history?start=${startTime.toISOString()}&end=${endTime.toISOString()}
                    this.generateHistoricalData(startTime, endTime, settings.maxPoints);
                    
                } catch (error) {
                    console.error('Error loading historical data:', error);
                }
            }

            generateHistoricalData(startTime, endTime, maxPoints) {
                // For historical data, we would call actual temporal endpoints like:
                // /api/v1/entities/history?start=${startTime.toISOString()}&end=${endTime.toISOString()}
                // 
                // Since we don't have historical metrics stored yet, start with empty charts
                // Real implementation would populate with actual temporal data
                
                console.log(`Historical data range: ${startTime.toISOString()} to ${endTime.toISOString()}`);
                console.log(`Would load ${maxPoints} data points for time range ${this.currentTimeRange}`);
                
                // TODO: Replace with real temporal API calls
                // For now, charts start empty and fill with real-time data
                
                // Update all charts to ensure they're ready
                Object.values(this.charts).forEach(chart => {
                    if (chart && chart.update) chart.update();
                });
            }

            formatTimeLabel(timestamp) {
                const settings = this.timeRangeSettings[this.currentTimeRange];
                
                if (settings.minutes <= 60) {
                    // For short ranges, show time only
                    return timestamp.toLocaleTimeString('en-US', { 
                        hour12: false, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                } else if (settings.minutes <= 1440) {
                    // For daily ranges, show time
                    return timestamp.toLocaleTimeString('en-US', { 
                        hour12: false, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                } else {
                    // For multi-day ranges, show date
                    return timestamp.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                }
            }


            async setChartTimeRange(chartId, range) {
                // Find the chart container and update active button
                const chartElement = document.getElementById(chartId + 'Chart');
                if (!chartElement) return;
                
                const container = chartElement.closest('.chart-container');
                if (!container) return;
                
                // Update active button within this chart's overlay
                container.querySelectorAll('.chart-time-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Find and activate the clicked button
                const clickedBtn = [...container.querySelectorAll('.chart-time-btn')].find(btn => 
                    btn.textContent.trim() === range
                );
                if (clickedBtn) {
                    clickedBtn.classList.add('active');
                }
                
                // Set time range for this chart and regenerate data
                if (!this.chartTimeRanges) this.chartTimeRanges = {};
                this.chartTimeRanges[chartId] = range;
                
                await this.initializeChartWithTimeRange(chartId, range);
            }

            async initializeChartWithTimeRange(chartId, range) {
                const chart = this.charts[chartId];
                if (!chart) return;
                
                const settings = this.timeRangeSettings[range];
                const endTime = new Date();
                const startTime = new Date(endTime.getTime() - (settings.minutes * 60 * 1000));
                
                // Generate complete time axis with all labels
                const timeLabels = [];
                const dataPoints = [];
                const timespan = endTime.getTime() - startTime.getTime();
                const interval = timespan / settings.maxPoints;
                
                for (let i = 0; i < settings.maxPoints; i++) {
                    const timestamp = new Date(startTime.getTime() + (i * interval));
                    timeLabels.push(this.formatTimeLabel(timestamp));
                    dataPoints.push(0); // Start with zeros
                }
                
                // Update chart with empty timeline first
                chart.data.labels = timeLabels;
                chart.data.datasets[0].data = dataPoints;
                chart.update();
                
                // Load historical data based on chart type
                await this.loadHistoricalDataForChart(chartId, range, chart, timeLabels, startTime.getTime(), interval);
            }
            
            async loadHistoricalDataForChart(chartId, range, chart, timeLabels, startTimeMs, intervalMs) {
                const metricsMap = {
                    'performance': 'storage_read_duration_ms',
                    'responseTime': 'storage_read_duration_ms', 
                    'requestVolume': 'query_result_count',
                    'storageRead': 'storage_read_duration_ms',
                    'storageWrite': 'storage_read_duration_ms'
                };
                
                const metricName = metricsMap[chartId];
                if (!metricName) return;
                
                try {
                    console.log(`Loading historical data for ${chartId} using metric ${metricName}`);
                    const metricsData = await this.apiCall(`/api/v1/metrics/history?metric_name=${metricName}&range=${range}`);
                    if (metricsData && metricsData.data_points && metricsData.data_points.length > 0) {
                        console.log(`Loaded ${metricsData.data_points.length} data points for ${chartId}`);
                        this.mapHistoricalDataToChart(chart, metricsData.data_points, timeLabels, startTimeMs, intervalMs);
                    } else {
                        console.warn(`No historical data available for ${chartId}`);
                    }
                } catch (error) {
                    console.warn(`Could not load historical data for ${chartId}:`, error);
                }
            }

            mapHistoricalDataToChart(chart, dataPoints, timeLabels, startTimeMs, intervalMs) {
                // Create new data array based on timeline
                const chartData = new Array(timeLabels.length).fill(0);
                
                // Map each historical data point to the nearest timeline slot
                dataPoints.forEach(point => {
                    const timestamp = new Date(point.timestamp).getTime();
                    const timeSlot = Math.floor((timestamp - startTimeMs) / intervalMs);
                    
                    // Only include data points within our time range
                    if (timeSlot >= 0 && timeSlot < chartData.length) {
                        // Take the average if multiple points map to the same slot
                        if (chartData[timeSlot] === 0) {
                            chartData[timeSlot] = point.value;
                        } else {
                            chartData[timeSlot] = (chartData[timeSlot] + point.value) / 2;
                        }
                    }
                });
                
                // Update chart with historical data
                chart.data.datasets[0].data = chartData;
                chart.update('none'); // Update without animation for performance
            }

            addDataPoint(chart, label, value, update = true) {
                if (!chart || !chart.data) return;
                
                chart.data.labels.push(label);
                chart.data.datasets[0].data.push(value);
                
                if (update) {
                    chart.update('none');
                }
            }

            updateRefreshInterval() {
                const settings = this.timeRangeSettings[this.currentTimeRange];
                
                // Clear existing intervals
                if (this.refreshInterval) clearInterval(this.refreshInterval);
                if (this.chartUpdateInterval) clearInterval(this.chartUpdateInterval);
                
                // Set new intervals based on time range
                this.refreshInterval = setInterval(() => this.refreshData(), 30000);
                this.chartUpdateInterval = setInterval(() => this.updateCharts(), settings.interval);
            }

            showAlert(message, type = 'info') {
                // Remove existing alerts
                document.querySelectorAll('.alert-overlay').forEach(alert => alert.remove());
                
                const alertOverlay = document.createElement('div');
                alertOverlay.className = 'alert-overlay';
                alertOverlay.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    min-width: 300px;
                    max-width: 500px;
                    padding: 15px 20px;
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    color: white;
                    font-weight: 500;
                    background: ${type === 'success' ? '#38a169' : type === 'error' ? '#e53e3e' : '#4299e1'};
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                `;
                
                alertOverlay.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${message}</span>
                        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; font-size: 18px; cursor: pointer; margin-left: 10px;">&times;</button>
                    </div>
                `;
                
                document.body.appendChild(alertOverlay);
                
                // Trigger animation
                setTimeout(() => {
                    alertOverlay.style.transform = 'translateX(0)';
                }, 10);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (alertOverlay.parentElement) {
                        alertOverlay.style.transform = 'translateX(100%)';
                        setTimeout(() => alertOverlay.remove(), 300);
                    }
                }, 5000);
            }

            async testAPI() {
                const method = document.getElementById('apiMethod').value;
                const endpoint = document.getElementById('apiEndpoint').value;
                const body = document.getElementById('apiBody').value;
                
                try {
                    const result = await this.apiCall(endpoint, method, body ? JSON.parse(body) : null);
                    document.getElementById('apiResponse').value = JSON.stringify(result, null, 2);
                } catch (error) {
                    document.getElementById('apiResponse').value = `Error: ${error.message}`;
                }
            }

            startAutoRefresh() {
                // Load initial historical data
                this.loadHistoricalData();
                
                // Set up refresh intervals based on current time range
                this.updateRefreshInterval();
            }

            // Utility functions
            getEntityType(entity) {
                if (!entity.tags) return 'unknown';
                
                // Fast path: look for type: tag first
                for (const tag of entity.tags) {
                    if (tag.startsWith('type:')) {
                        return tag.split('type:')[1].split('|')[0];
                    }
                }
                
                // Fast path: check first few tags for metric indicators
                for (let i = 0; i < Math.min(entity.tags.length, 10); i++) {
                    const tag = entity.tags[i];
                    if (tag.includes('value:') || tag.includes('count:') || tag.includes('avg:')) {
                        return 'metric';
                    }
                }
                
                return 'unknown';
            }

            extractTagValue(entity, tagKey) {
                if (!entity.tags) return 'N/A';
                const tag = entity.tags.find(t => t.includes(tagKey + ':'));
                return tag ? tag.split(tagKey + ':')[1].split('|')[0] : 'N/A';
            }

            getLatestValue(metric) {
                if (!metric.tags) return '0';
                const valueTag = metric.tags.find(t => t.includes('value:'));
                return valueTag ? valueTag.split('value:')[1].split('|')[0] : '0';
            }

            formatDate(timestamp) {
                if (!timestamp) return 'N/A';
                return new Date(timestamp).toLocaleDateString();
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            showAlert(message, type = 'success') {
                const alertHTML = `<div class="alert alert-${type}">${message}</div>`;
                // You can implement this to show alerts in a toast or modal
                console.log(alertHTML);
            }

            // User Management Functions
            showCreateUserModal() {
                const modalHTML = `
                    <div id="userModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div class="card" style="width: 500px; margin: 0;">
                            <h3>Create New User</h3>
                            <div class="form-group">
                                <label>Username:</label>
                                <input type="text" id="newUsername" required>
                            </div>
                            <div class="form-group">
                                <label>Email:</label>
                                <input type="email" id="newEmail" required>
                            </div>
                            <div class="form-group">
                                <label>Password:</label>
                                <input type="password" id="newPassword" required>
                            </div>
                            <div class="form-group">
                                <label>Role:</label>
                                <select id="newRole">
                                    <option value="user">User</option>
                                    <option value="admin">Admin</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="app.closeModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="app.createUser()">Create User</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            showChangePasswordModal(userId, username) {
                const modalHTML = `
                    <div id="passwordModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div class="card" style="width: 500px; margin: 0;">
                            <h3>Change Password for ${username}</h3>
                            <div class="form-group">
                                <label>Current Password:</label>
                                <input type="password" id="currentPassword" required>
                            </div>
                            <div class="form-group">
                                <label>New Password:</label>
                                <input type="password" id="newPasswordChange" required>
                            </div>
                            <div class="form-group">
                                <label>Confirm New Password:</label>
                                <input type="password" id="confirmPassword" required>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="app.closeModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="app.changePassword('${username}')">Change Password</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            async createUser() {
                const username = document.getElementById('newUsername').value;
                const email = document.getElementById('newEmail').value;
                const password = document.getElementById('newPassword').value;
                const role = document.getElementById('newRole').value;

                if (!username || !email || !password) {
                    this.showAlert('All fields are required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall('/api/v1/users/create', 'POST', {
                        username,
                        email,
                        password,
                        role
                    });

                    if (result.error) {
                        this.showAlert(`Error creating user: ${result.error}`, 'error');
                    } else {
                        this.showAlert('User created successfully', 'success');
                        this.closeModal();
                        await this.loadUsers();
                    }
                } catch (error) {
                    this.showAlert(`Error creating user: ${error.message}`, 'error');
                }
            }

            async changePassword(username) {
                const currentPassword = document.getElementById('currentPassword').value;
                const newPassword = document.getElementById('newPasswordChange').value;
                const confirmPassword = document.getElementById('confirmPassword').value;

                if (!currentPassword || !newPassword || !confirmPassword) {
                    this.showAlert('All fields are required', 'error');
                    return;
                }

                if (newPassword !== confirmPassword) {
                    this.showAlert('New passwords do not match', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall('/api/v1/users/change-password', 'POST', {
                        username,
                        current_password: currentPassword,
                        new_password: newPassword
                    });

                    if (result.error) {
                        this.showAlert(`Error changing password: ${result.error}`, 'error');
                    } else {
                        this.showAlert('Password changed successfully', 'success');
                        this.closeModal();
                    }
                } catch (error) {
                    this.showAlert(`Error changing password: ${error.message}`, 'error');
                }
            }

            showCreateEntityModal() {
                const datasetInfo = this.currentDataset ? 
                    `<p><strong>Dataset:</strong> ${this.datasets.find(d => d.id === this.currentDataset)?.name || 'Selected Dataset'}</p>` :
                    `<p><strong>Scope:</strong> Global (no dataset selected)</p>`;
                
                const modalHTML = `
                    <div id="entityModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div class="card" style="width: 500px; margin: 0;">
                            <h3>Create New Entity</h3>
                            ${datasetInfo}
                            <div class="form-group">
                                <label>Type:</label>
                                <input type="text" id="entityType" placeholder="e.g., document, task, user" required>
                            </div>
                            <div class="form-group">
                                <label>Tags (one per line):</label>
                                <textarea id="entityTags" rows="4" placeholder="status:active&#10;priority:high&#10;category:work"></textarea>
                            </div>
                            <div class="form-group">
                                <label>Content (optional):</label>
                                <textarea id="entityContent" rows="3" placeholder="Entity content or description"></textarea>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="app.closeModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="app.createEntity()">Create Entity</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            async createEntity() {
                const type = document.getElementById('entityType').value;
                const tagsText = document.getElementById('entityTags').value;
                const content = document.getElementById('entityContent').value;

                if (!type) {
                    this.showAlert('Entity type is required', 'error');
                    return;
                }

                // Parse tags from textarea
                const tags = tagsText.split('\n')
                    .filter(line => line.trim())
                    .map(line => line.trim());

                // Add type tag if not already present
                if (!tags.some(tag => tag.startsWith('type:'))) {
                    tags.unshift(`type:${type}`);
                }

                try {
                    const endpoint = this.currentDataset ? 
                        `/api/v1/datasets/${this.currentDataset}/entities/create` : 
                        '/api/v1/entities/create';
                    
                    const result = await this.apiCall(endpoint, 'POST', {
                        tags,
                        content: content || ''
                    });

                    if (result.error) {
                        this.showAlert(`Error creating entity: ${result.error}`, 'error');
                    } else {
                        this.showAlert('Entity created successfully', 'success');
                        this.closeModal();
                        await this.loadEntities();
                    }
                } catch (error) {
                    this.showAlert(`Error creating entity: ${error.message}`, 'error');
                }
            }

            showCreateDatasetModal() {
                const modalHTML = `
                    <div id="datasetModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div class="card" style="width: 500px; margin: 0;">
                            <h3>Create New Dataset</h3>
                            <div class="form-group">
                                <label>Name:</label>
                                <input type="text" id="datasetName" required>
                            </div>
                            <div class="form-group">
                                <label>Description:</label>
                                <textarea id="datasetDescription" rows="3"></textarea>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="app.closeModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="app.createDataset()">Create Dataset</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            async createDataset() {
                const name = document.getElementById('datasetName').value;
                const description = document.getElementById('datasetDescription').value;

                if (!name) {
                    this.showAlert('Dataset name is required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall('/api/v1/datasets', 'POST', {
                        name,
                        description: description || `Dataset: ${name}`
                    });

                    if (result.error) {
                        this.showAlert(`Error creating dataset: ${result.error}`, 'error');
                    } else {
                        this.showAlert('Dataset created successfully', 'success');
                        this.closeModal();
                        await this.loadDatasets();
                    }
                } catch (error) {
                    this.showAlert(`Error creating dataset: ${error.message}`, 'error');
                }
            }

            async viewDataset(datasetId) {
                // Navigate to entities tab and filter by dataset
                switchTab('entities');
                this.showAlert('Dataset view functionality coming soon', 'info');
            }

            async editDataset(datasetId) {
                this.showAlert('Dataset edit functionality coming soon', 'info');
            }

            // Temporal Query Functions
            async queryAsOf() {
                const entityId = document.getElementById('temporalEntityId').value;
                const timestamp = document.getElementById('temporalTimestamp').value;

                if (!entityId || !timestamp) {
                    this.showAlert('Entity ID and timestamp are required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall(`/api/v1/entities/as-of?id=${entityId}&timestamp=${timestamp}T00:00:00Z`);
                    document.getElementById('temporalResults').innerHTML = `
                        <h5>As-Of Query Result</h5>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    `;
                } catch (error) {
                    document.getElementById('temporalResults').innerHTML = `
                        <div class="alert alert-error">Error: ${error.message}</div>
                    `;
                }
            }

            async queryHistory() {
                const entityId = document.getElementById('temporalEntityId').value;

                if (!entityId) {
                    this.showAlert('Entity ID is required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall(`/api/v1/entities/history?id=${entityId}`);
                    document.getElementById('temporalResults').innerHTML = `
                        <h5>Entity History</h5>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    `;
                } catch (error) {
                    document.getElementById('temporalResults').innerHTML = `
                        <div class="alert alert-error">Error: ${error.message}</div>
                    `;
                }
            }

            async queryChanges() {
                const entityId = document.getElementById('temporalEntityId').value;
                const fromTime = document.getElementById('temporalFromTime').value;
                const toTime = document.getElementById('temporalToTime').value;

                if (!entityId || !fromTime || !toTime) {
                    this.showAlert('Entity ID, from time, and to time are required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall(`/api/v1/entities/changes?id=${entityId}&from=${fromTime}T00:00:00Z&to=${toTime}T00:00:00Z`);
                    document.getElementById('temporalResults').innerHTML = `
                        <h5>Entity Changes</h5>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    `;
                } catch (error) {
                    document.getElementById('temporalResults').innerHTML = `
                        <div class="alert alert-error">Error: ${error.message}</div>
                    `;
                }
            }

            async queryDiff() {
                const entityId = document.getElementById('temporalEntityId').value;
                const fromTime = document.getElementById('temporalFromTime').value;
                const toTime = document.getElementById('temporalToTime').value;

                if (!entityId || !fromTime || !toTime) {
                    this.showAlert('Entity ID, from time, and to time are required', 'error');
                    return;
                }

                try {
                    const result = await this.apiCall(`/api/v1/entities/diff?id=${entityId}&from=${fromTime}T00:00:00Z&to=${toTime}T00:00:00Z`);
                    document.getElementById('temporalResults').innerHTML = `
                        <h5>Entity Diff</h5>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    `;
                } catch (error) {
                    document.getElementById('temporalResults').innerHTML = `
                        <div class="alert alert-error">Error: ${error.message}</div>
                    `;
                }
            }

            async queryMetrics() {
                const metricName = document.getElementById('metricName').value;
                const timeRange = document.getElementById('timeRange').value;

                if (!metricName) {
                    this.showAlert('Metric name is required', 'error');
                    return;
                }

                try {
                    // Query metrics history for the specified metric
                    const result = await this.apiCall(`/api/v1/metrics/history?metric=${metricName}&range=${timeRange}`);
                    
                    if (result && result.data && result.data.length > 0) {
                        this.displayCustomChart(result.data, metricName);
                        document.getElementById('customMetricsChart').style.display = 'block';
                        this.showAlert(`Loaded ${result.data.length} data points for ${metricName}`, 'success');
                    } else {
                        this.showAlert(`No data found for metric: ${metricName}`, 'info');
                        document.getElementById('customMetricsChart').style.display = 'none';
                    }
                } catch (error) {
                    this.showAlert(`Error querying metrics: ${error.message}`, 'error');
                    document.getElementById('customMetricsChart').style.display = 'none';
                }
            }

            async loadDatasetSelector() {
                try {
                    this.datasets = await this.apiCall('/api/v1/datasets');
                    const selector = document.getElementById('datasetSelector');
                    
                    // Clear existing options
                    selector.innerHTML = '';
                    
                    // Add global option
                    const globalOption = document.createElement('option');
                    globalOption.value = '';
                    globalOption.textContent = 'All Entities (Global)';
                    selector.appendChild(globalOption);
                    
                    // Add dataset options
                    this.datasets.forEach(dataset => {
                        const option = document.createElement('option');
                        option.value = dataset.id;
                        option.textContent = this.extractTagValue(dataset, 'name') || dataset.id.substring(0, 12);
                        selector.appendChild(option);
                    });
                    
                    // Set first dataset as default if any exist
                    if (this.datasets.length > 0) {
                        this.currentDataset = this.datasets[0].id;
                        selector.value = this.currentDataset;
                    }
                    
                } catch (error) {
                    console.error('Error loading datasets:', error);
                    document.getElementById('datasetSelector').innerHTML = '<option value="">Error loading datasets</option>';
                }
            }

            async switchDataset() {
                const selector = document.getElementById('datasetSelector');
                this.currentDataset = selector.value || null;
                
                console.log('Switched to dataset:', this.currentDataset || 'Global');
                
                // Refresh entity data for the new dataset
                await this.loadEntities();
                
                // Show feedback to user
                const datasetName = this.currentDataset ? 
                    (this.datasets.find(d => d.id === this.currentDataset)?.name || 'Selected Dataset') : 
                    'Global View';
                this.showAlert(`Switched to: ${datasetName}`, 'info');
            }

            displayCustomChart(data, metricName) {
                const ctx = document.getElementById('customChart').getContext('2d');
                
                // Destroy existing chart if it exists
                if (this.customChart) {
                    this.customChart.destroy();
                }

                // Prepare data for Chart.js
                const labels = data.map(point => new Date(point.timestamp).toLocaleTimeString());
                const values = data.map(point => parseFloat(point.value) || 0);

                this.customChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: metricName,
                            data: values,
                            borderColor: '#4299e1',
                            backgroundColor: 'rgba(66, 153, 225, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Value'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${metricName} - ${document.getElementById('timeRange').value}`
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            async viewEntity(entityId) {
                try {
                    // Fetch the entity details
                    const endpoint = this.currentDataset ? 
                        `/api/v1/datasets/${this.currentDataset}/entities/get?id=${entityId}` : 
                        `/api/v1/entities/get?id=${entityId}`;
                    
                    const entity = await this.apiCall(endpoint);
                    
                    if (entity.error) {
                        this.showAlert(`Error loading entity: ${entity.error}`, 'error');
                        return;
                    }

                    this.showEntityViewModal(entity);
                } catch (error) {
                    this.showAlert(`Error loading entity: ${error.message}`, 'error');
                }
            }

            showEntityViewModal(entity) {
                const modalHTML = `
                    <div id="entityViewModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div class="card" style="width: 700px; max-height: 80vh; overflow-y: auto; margin: 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h3>Entity Details</h3>
                                <button onclick="app.closeModal()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                            </div>
                            
                            <div class="form-group">
                                <label><strong>ID:</strong></label>
                                <div style="font-family: monospace; background: #f7fafc; padding: 8px; border-radius: 4px; word-break: break-all;">
                                    ${entity.id}
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label><strong>Type:</strong></label>
                                <div>${this.getEntityType(entity)}</div>
                            </div>
                            
                            <div class="form-group">
                                <label><strong>Created:</strong></label>
                                <div>${this.formatDate(entity.created_at)}</div>
                            </div>
                            
                            ${entity.updated_at ? `
                                <div class="form-group">
                                    <label><strong>Updated:</strong></label>
                                    <div>${this.formatDate(entity.updated_at)}</div>
                                </div>
                            ` : ''}
                            
                            <div class="form-group">
                                <label><strong>Tags (${entity.tags?.length || 0}):</strong></label>
                                <div style="max-height: 200px; overflow-y: auto; background: #f7fafc; padding: 10px; border-radius: 4px;">
                                    ${entity.tags && entity.tags.length > 0 ? 
                                        entity.tags.map(tag => `
                                            <div style="margin: 2px 0; font-family: monospace; font-size: 0.9rem;">
                                                <span style="background: #e2e8f0; padding: 2px 6px; border-radius: 3px; margin-right: 5px;">
                                                    ${tag.includes('|') ? tag.split('|')[1] : tag}
                                                </span>
                                                ${tag.includes('|') ? `<small style="color: #666;">${tag.split('|')[0]}</small>` : ''}
                                            </div>
                                        `).join('') : 
                                        '<em>No tags</em>'
                                    }
                                </div>
                            </div>
                            
                            ${entity.content ? `
                                <div class="form-group">
                                    <label><strong>Content:</strong></label>
                                    <div style="max-height: 200px; overflow-y: auto; background: #f7fafc; padding: 10px; border-radius: 4px; white-space: pre-wrap; font-family: monospace; font-size: 0.9rem;">
                                        ${typeof entity.content === 'string' ? entity.content : JSON.stringify(entity.content, null, 2)}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="app.viewEntityHistory('${entity.id}')">View History</button>
                                <button class="btn btn-primary" onclick="app.editEntity('${entity.id}')">Edit Entity</button>
                                <button class="btn btn-secondary" onclick="app.closeModal()">Close</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }

            async viewEntityHistory(entityId) {
                try {
                    const result = await this.apiCall(`/api/v1/entities/history?id=${entityId}`);
                    
                    // Close current modal and show history
                    this.closeModal();
                    
                    const modalHTML = `
                        <div id="entityHistoryModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                            <div class="card" style="width: 800px; max-height: 80vh; overflow-y: auto; margin: 0;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                    <h3>Entity History</h3>
                                    <button onclick="app.closeModal()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                                </div>
                                
                                <div style="background: #f7fafc; padding: 15px; border-radius: 6px; max-height: 400px; overflow-y: auto;">
                                    <pre style="margin: 0; white-space: pre-wrap; font-size: 0.9rem;">${JSON.stringify(result, null, 2)}</pre>
                                </div>
                                
                                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                    <button class="btn btn-secondary" onclick="app.viewEntity('${entityId}')">Back to Entity</button>
                                    <button class="btn btn-secondary" onclick="app.closeModal()">Close</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                } catch (error) {
                    this.showAlert(`Error loading entity history: ${error.message}`, 'error');
                }
            }

            async editEntity(entityId) {
                this.showAlert('Entity edit functionality coming soon', 'info');
                // TODO: Implement entity edit modal
            }

            async deleteEntity(entityId) {
                if (confirm('Are you sure you want to delete this entity?')) {
                    this.showAlert('Entity delete functionality coming soon', 'info');
                    // TODO: Implement entity deletion
                }
            }

            async saveEntity() {
                this.showAlert('Entity save functionality coming soon', 'info');
                // TODO: Implement entity save
            }

            searchEntities() {
                const searchTerm = document.getElementById('entitySearch').value.toLowerCase();
                console.log('Searching entities for:', searchTerm);
                // TODO: Implement entity search filtering
                this.showAlert(`Search for "${searchTerm}" - filtering coming soon`, 'info');
            }

            setChartTimeRange(range) {
                this.currentTimeRange = range;
                console.log('Chart time range set to:', range);
                this.updateRefreshInterval();
                this.showAlert(`Chart time range set to: ${range}`, 'info');
            }

            closeModal() {
                const modals = document.querySelectorAll('#userModal, #passwordModal, #datasetModal, #entityModal, #entityViewModal, #entityHistoryModal');
                modals.forEach(modal => modal.remove());
            }
        }

        // Tab switching function
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
        }

        // Initialize application
        const app = new EntityDBAdmin();
    </script>
</body>
</html>